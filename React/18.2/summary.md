# React 18 Summary
React18 最重要的更新内容是： 并发。对于 React 开发者来说，其实这个只是底层的改动，开发者本身并不会感知到这些变化，开发者也没有必要了解底层的运行原理。  
但为了追求更高的技术层次，了解底层工作原理也是值得的。  
并发模式 React 的一个特性就是渲染可中断。当升级到 React18 后，***如果没有引入并发功能，更新内容渲染的方式和之前一样，通过单一且不可中断的同步事务进行处理***。同步意味着，一旦开始渲染就无法中断，直到用户可以在屏幕上看到渲染结果。  
在并发渲染中，情况并不总是这样。React 可能开始渲染一个更新，然后中途挂起，稍后又继续。它甚至可能完全放弃一个正在进行的渲染。React 保证即使渲染被中断，UI 也会保持一致。  
***为了实现这一点，它会在整个 DOM 树被计算完毕前一直等待，完毕后再进行 DOM 变更***。这样做，React 就可以在后台提前准备新的屏幕内容，而不阻塞主线程。这意味着用户输入可以立即被响应，即使存在大量渲染任务，也能有流畅的用户体验。  
另一个例子是可重用状态。并发 React 可以从屏幕中移除部分 UI, 然后在稍后将它们再添加回来，并重用之前的状态。例如，当用户来回切换标签页，React 应该能够立即将屏幕恢复到它先前的状态。
## 渐进式采用并发特性
React18 的新渲染行为***只在你的应用中使用新功能的部分启用***，比如使用 *startTransition* 在屏幕内容之间进行导航，使用 *useDefferedValue* 来节流处理开销巨大的重新渲染。

## React18 新功能
### 自动批处理
在 React18 之前，promise, setTimeout 等原生应用的事件处理函数中的状态更新并不会被自动批处理
```js
// 以前: 只有 React 事件会被批处理。
setTimeout(() => {
  setCount(c => c + 1);
  setFlag(f => !f);
  // React 会渲染两次，每次更新一个状态（没有批处理）
}, 1000);

// 现在: 超时，promise，本机事件处理程序
// 原生应用时间处理程序或者任何其他时间都被批处理了
setTimeout(() => {
  setCount(c => c + 1);
  setFlag(f => !f);
  // 最终，React 将仅会重新渲染一次（这就是批处理！）
}, 1000);
```
### 过度更新
过渡(transition) 用来区分紧急更新和非紧急更新。
* 紧急更新对应直接的交互，点击，输入，按压等
* 非紧急更新将 UI 从一个视图过渡到另一个
紧急更新必须及时响应，否则就会觉得不对劲。但过渡更新可以有一定的延迟，用户是有一定预期的。通常情况下，为了更好的用户体验，一个用户输入应该同时产生一个紧急更新和一个过渡更新。你可以在一个 *startTransition* 中告诉 React 哪些更新是紧急更新，哪些又是过渡更新
```js
import { startTransition } from 'react';

// 紧急更新: 显示输入的内容
setInputValue(input);

// 将任何内部的状态更新都标记为过渡更新
startTransition(() => {
  // 过渡更新: 展示结果. searchQuery 引发的渲染会放在过渡渲染中，由后台处理
  setSearchQuery(input);
});
```
***过渡更新会被新的紧急更新中断***。这意味着，如果一个过渡更新被用户中断，比如快速输入多个字符，React 将会抛弃未完成的渲染结果，然后仅渲染最新的内容。
* useTransition, 一个开启过渡更新的 hook, 用于跟踪待定转场状态
* startTransition, 在 hook 不可用时，用于开启过渡
如果更新内容被重新挂起，过渡机制也会告诉 React 在后台渲染过渡内容时继续展示当前内容
### Suspense
Suspense 和 transition 结合使用效果更好