1. c++ 程序运行时内存是怎么划分的？  
   * 全局数据区，用来存储全局变量，静态数据成员等
   * 代码区，用来存储函数代码
   * 栈，函数运行时分配的区域，存储局部变量，函数参数，返回值等
   * 堆，动态分配内存的区域

2. 顶层 const 指针和底层 const 指针的区别？  
   顶层 const 指针就是本身是常量的指针，即 char * const p, 而底层 const 指针就是指向常量的指针，即 const char * p.   
   但指向常量的指针不代表它指向的对象一定是常量，只是规定不能通过该指针修改对象的值。 
3. 引用和常量引用，以及引用和指针的区别？  
   引用是变量的别名，int &b = a; 其实就是一个语法糖，其底层实现就是就是一个指针，只是这个指针本身是常量，必须在声明时初始化，且不可指向其它变量, 等价于 int * const p。  
   常量引用就是引用对象变量是常量，不可以通过该引用修改变量的值。等价于 const int * const p  
   引用和指针的区别就是普通指针和本身是常量的指针的区别，特殊在于引用不可为空，但指针可为 NULL, 而且引用必须初始化，且不可指向其它变量。
4. char* p1 = "hello world" 和 char p2[] = "hello world" 的区别？  
   "hello world" 是静态字符串，p1 为指向该静态字符串的首字母的指针，不可以通过该指针修改变量的值。  
   p2 就是一个数组，该数组的内容就是字符串 "hello world", 相当于把静态字符串拷贝到了数组。可以通过 p2 修改数据。
5. 如果定义类型别名 typeof char* PC, 那么 const PC p1 是什么类型，const PC * p2 是什么类型， const PC[10] p3 是什么类型？  
   首先 PC 是指向 char 的指针，const PC 表示该指针是一个常量，因为 const 修饰的是基础类型，PC的基础类型是指针。 
   p2 就是一个指向 p1 类型的指针。  
   p3 是有10个元素的数组，数组的元素类型是 const PC
6. 一个数组 int a[10], 那么 p1 = a 是什么类型， p2 = &a 是什么类型，另一个数组 int b[2][3], p3 = b 是什么类型，p4 = &b 是什么类型？ p1 + 1, p2 + 1, p3 + 1, p4 + 1 分别有什么效果？sizeof(p1), sizeof(p2), sizeof(p3), sizeof(p4)，sizeof(a),sizeof(b) 分别返回多少？b[1][2] 换成指针的写法，应该怎么写？  
   在表达式里，数组名会被默认转换为指向数组首元素的指针，所以 p1 是 int *. p3 则是 int(*)[3]  
   对数组名取地址，返回的是指向整个数组的指针，即 p2 是 int(*)[10], p4 则是 int(*)[2][3]  
   对指针 + 1, 则是将指针指向的地址向后偏移 1 个指针所指变量的大小，那么 p1 + 1 则是 p1 向后移位 sizeof(int), 也就是 a[1]的地址， p2 + 1 则是 p2 向后移位 10 * sizeof(int), p3 + 1 其实就是 b[1] 的地址，p4 + 1 则是 p4 向后移位 6 * sizeof(int)  
   sizeof 一个指针，则会根据当前系统位数返回大小，32 位返回 4, 64 位返回 8. sizeof 作用于数组名时，则不会默认将数组名转换为指向第一个元素的指针，而是会返回整个数组的大小。  
   b[1][2] 换成指针写法，就是 *(*(b + 1) + 2). 首先 b + 1 指向了 b[1], 对其解引用，返回的则是 b[1] 这个数组。同样的，这个数组也是一个匿名数组，*(b + 1) + 2 会将 *(b + 1) 转换为指向该匿名数组首元素的指针， 然后通过 +2，指向了 b[1][2] 这个 int.
7. 一个char * p = NULL, 那么 sizeof(p) 返回多少？sizeof(*p) 返回多少？这里 *p 会触发 null pointer expcetion 吗？  
   对于指针，返回的都是固定大小，与 #6 一样。  
   而 sizeof(expression) 并不会真正的去执行 expression, 它只会推导出 expression 的返回值类型，因为 p 是 char*, 所以 sizeof(*p) 会返回 1， 即使 p 本身是一个 nullptr
8. 函数指针是什么？怎么定义一个函数，该函数返回一个指向数组的指针？或者返回一个函数指针？  
   函数指针是指指向函数的指针，函数不能作为参数或者返回值传递，但是函数指针可以。  
   int (* func())[10], 或者通过 后置类型来定义， auto func() -> int(*)[10]  
   int (* func())(int)
9. 类成员函数的 this 指针？常量成员函数的用处？常量成员函数和普通成员函数能重载吗？常量对象能调用普通的成员函数吗？  
   this 指针本质上是编译器为成员函数隐式添加的参数，该指针指向了调用该方法的对象，且该指针本身为常量。  
   this 指针在函数开始执行前构造，在函数结束时消耗。  
   常量成员函数即是在成员函数后面声明了 const 的成员函数，有了这个声明，编译器就会把 this 指针编译为 const T * const this, 则不能通过 this 指针来修改所指对象的数据。  
   常量成员函数和非常量成员函数是可以重载的，如果是常量对象，则使用常量成员函数，如果是非常量，则使用普通成员函数。  
   且常量对象不能调用非常量成员函数，但非常量对象可以调用常量成员函数。、

10. 虚函数？虚析构函数？构造函数为什么不能为虚函数？纯虚函数？
    虚函数通过声明函数为 virtual 来实现，虚函数允许在声明时使用静态类型，在运行时，使用动态类型所对应的虚函数实现。如果一个类有虚函数，那么该类的对象里就会有一个指针，该指针指向了虚函数表。  
    只有虚函数才可以被覆盖，如果不是虚函数，即使在基类和子类里定义两个完全相同的方法，也是两个不同的方法。    
    虚析构函数就是为了在 delete p 时，也要根据 p 的动态类型而不是静态类型来调用对应的析构函数，防止资源泄露。  
    构造函数在构造时必须知道具体的类型，和虚函数的定义违背。  
    纯虚函数就是将虚函数没有任何实现，比如 *virtual void f() = 0*, 有纯虚函数的类不可以实例化。
```java
class A {
    public:
        A(int d=0) {
            data = d;
        }
        
        int getData() {
            return doGetData();
        }
        
        virtual int doGetData() {
            return data;
        }
    private:
        int data;
};

class B: public A {
    private:
        int data;
    public:
        B(int d = 1) {
            data = d;
        }
        
        int doGetData() {
            return data;
        }
};

class C: public B {
    private:
        int data;
    public:
        C(int d = 2) {
            data = d;
        }
};
int main()
{
    cout<<"Hello World"<<endl;
    C c(10);
    
    cout << c.getData()<<endl;
    cout << c.A::getData()<<endl;
    cout << c.B::getData()<<endl;
    cout << c.C::getData()<<endl;
    cout << c.doGetData()<<endl;
    cout << c.A::doGetData()<<endl;
    cout << c.B::doGetData()<<endl;
    cout << c.C::doGetData()<<endl;
    return 0;
}
```
前四个都会调用到 A::getData, 该方法又会调用虚函数 doGetData, 又因为 this 对象实际指向的是 C对象，那么又要从 C 开始找起。从而找到了 B 里的 doGetData. 输出应该为 1 1 1 1 1 0 1 1.  
如果去掉 virtual 修饰，则应该输出 0 0 0 0 1 0 1 1. 因为在调用 A::getData 时，直接调用普通函数 doGetData, 所有都在 A的 作用域下完成。

1.  一个空类，会有什么默认生成的函数？在继承链中，构造函数，析构函数的执行顺序？  
    构造函数，析构函数，拷贝构造函数，赋值函数。  
    构造函数的执行顺序是先调用基类构造方法，在执行构造方法时，先执行初始化列表，再执行函数体。且成员变量是按照声明顺序进行初始化的。  
    析构函数则和构造函数相反，先执行函数体，再按照构造的逆序，执行成员变量的析构函数。如果是基础类型，则不需要析构。
    拷贝构造一般为 *A(const A &other)*, 赋值函数则为 *A & operator = (const A& other)*
```java
class A {
    public:
        virtual void f() {
            cout<< "A method"<<endl;
        }
        
        A() {
            cout << "A cons"<<endl;
        }
        ~A() {
            cout<< "A descontructor"<<endl;
        }
};
class B : public A {
    public:
        void f() {
            cout << "B method"<<endl;
        }
        
        B() {
            cout<< "B cons"<<endl;
        }
        ~B() {
            cout << "B descontructor"<<endl;
        }
};

int main()
{
    A a = B();
    a.f();
    return 0;
}
```
<b>上面示例会打印什么？如果将 A a = B() 替换为 A* a = new B();又会打印什么？程序有什么问题？</b>  
首先 B() 会构建 B 对象，那么依次调用 A,B 的构造函数，然后将这个临时 B 对象赋值构造给 a. 赋值完成后，临时的 B 对象被析构，依次调用 B, A 的析构函数。  
然后调用 a 对象的 f 方法。既是 f 方法是虚函数，但是 a 对象并不是指针或者引用，不具备多态的条件，那么直接调用 a 对象的 f 方法。  
之后 a 被析构，调用 a 的析构方法。  
<b>上述代码没有实现多态，为了实现多态，将 a 改为指针。这种情况下又会打印什么？又有什么问题？</b>
```java
int main()
{
    A* a = new B();
    a -> f();
    return 0;
}
```
首先在堆上构造 B 对象，依次调用 A, B的构造函数，然后将 B对象的指针赋给 a. 然后通过 a 调用 f 方法，因为 f 是虚函数，则此时根据动态类型，会调用 B 对象的 f 方法。 之后程序结束。  
<b>那么现在的问题在于，构建的对象没有被析构。那么再次修改，添加到 delete 语句后，又会打印什么？还有什么问题吗？</b>
```java
int main()
{
    A* a = new B();
    a -> f();
    delete a;
    return 0;
}
```
现在，因为添加了 *delete a*, 那么指针所对应的内存将被释放。因为 a 的静态类型是 A，那么会调用 A的析构函数。现在问题在于，我们实际构建的是 B 对象，但是现在只执行了 A 对象的析构函数，则很容易出现资源泄露的问题。怎么解决呢？通过将析构函数设置为虚函数。那么在 delete a 时，因为动态类型是 B，那么就会调用 B的析构函数，然后调用 A的析构函数。  
<b>如果现在想在 B 的 f 方法函数体内调用基类 A 的 f 方法实现，该怎么办呢？</b>
```java
class B: public A {
    void f() {
        A::f();
        cout << "B method"<<endl;
    }
}
``` 
通过作用域访问符来显示调用基类的方法。

2. 派生访问符的作用？即公有继承，私有继承和保护继承之间的区别是什么？
   首先要区分派生类成员函数和派生类对象对基类 public/protected/private 成员的访问权限。  
   不管是什么继承方式，对于派生类成员函数来说，private 成员都是不可访问的，public/protected 成员都是可以访问的。  
   区别在于派生类对象对基类成员的访问权限。    
   如果是公有继承，派生类对象只能访问基类 public 成员。并且派生类对基类成员的访问权限和基类一样，即基类的 public 在派生类中仍然被看作 public, protected 仍然被看作 protected.    
   如果是私有继承，那么派生类的对象将不能访问基类任何成员，且基类的所有成员都被当作 private 成员被继承。  
   如果是保护继承，派生类的对象也不能访问基类任何成员，且基类的 public/proteced 都被当作 protected 被继承。  
   基类成员的访问权限的继承，在派生类继续派生子类时，会产生效果。
3. 构造函数初始值列表？  
   常量和引用必须初始化，而不能赋值，所以除了类内初始化，还可以通过初始化列表来进行。  
   如果成员变量是类类型，但是该类类型没有默认构造函数，也必须通过初始化列表来进行初始化。因为如果有类成员变量没有默认构造函数，则编译器会将该类默认构造函数设置为 deleted， 该类必须自己实现一个构造函数，该构造函数必须负责初始化该类成员变量。但是因为它没有默认构造函数，也必须在初始化列表里对该类成员变量进行初始化。  
   如果子类想使用父类的有参构造函数，也只能通过初始化列表来指定，否则总是会调用父类的无参构造函数。        
   而构造函数体内对成员变量的赋值，并不是初始化，只是在初始化之后进行赋值而已。 简单来说，初始化列表就是在申请内存时，就直接对成员变量进行赋值，而不是先默认赋值，然后执行函数体进行再次赋值。
   需要注意的是，初始化列表是按照成员变量的定义顺序来执行的，而不是初始化列表里面的顺序。  
4.  怎么计算一个结构体，或者类的 sizeof 大小？
    首先，对象在内存的分布和系统设置的 *#pragma pack(n)* 中n 的大小有关，n 可以为 1， 2， 4， 默认值为 4. n 会影响对象成员的对齐方式。  
    每个成员的对齐系数为 min(len, n), len 是成员自己的长度，比如 char 长度为 1， n 为 4， 那么 char 的对齐系数就是1， 表示 char 可以在内存里一个接一个的排列，中间不需要有占位空间。  
    而 short 的长度为 2， 那么它的对齐系数就是 2，表示 short 必须要在偶数地址上摆放，举例来讲，就是如果一个对象有一个 char, 一个 short, 那么在 0x0位置摆放 char, 然后就只能在 0x2 位置摆放 short, 0x1则被占位，sizeof 该对象，返回的也是 4. 对于 int, 或者 double, long 之类的，它们的对齐系数就是 4.  
    最后整体对象的大小，必然是所有成员中最大的对齐系数的整数倍。
    ```java
    struct A {
        char a;
        char b;
        char c;
    }

    struct B {
        int a;
        char b;
        short c;
    }

    struct C {
        char a;
        int b;
        short c;
    }
    ```
5.  讲讲面向对象编程的理解，比如封装，继承，多态。
   封装其实就是数据内聚和数据隐藏，内聚可以提高复用性和可维护性，隐藏可以进行访问控制，达到信息隐藏的目的。  
   继承就是代码的复用和扩展，可以通过派生已有的类来复用已有的功能，也可以通过覆盖来改变父类的行为。  
   多态就是在编译时依赖于静态类型，但是在运行时，依赖于运行时的具体类型。指针或者引用的静态类型和动态类型可以不同，以及 virtual 的使用，是多态的基础。