# Java Lock
## Lock
为了更好的支持 并发，JDK 1.5 发布了 Lock 接口
```java
interface Lock {
    void lock()//尝试获取锁，获取后，该方法返回
    void lockInterruptibly() throws InterrupedException//与 lock 的区别在于该方法可以在获取锁的过程中响应中断
    boolean tryLock()//尝试非阻塞的获取锁，调用后，立即返回。如果成功，返回 true, 如果失败，返回 false
    boolean tryLock(long time, TimeUnit unit) throws InterrupedException//当在时限内获取锁，则返回 true, 当在时限内被中断，响应异常处理，当超时仍未获取锁，则返回 false
    void unlock()//释放锁
    Condition newCondition()//创建一个和当前 lock 对象绑定的 condition 对象
}
```
简单来说，*Lock* 用来增强 *synchronized*, 提供一些额外的特性， *Condition* 用来增强对锁对象的 *wait*, *notify* 等方法的使用。

## 队列同步器
队列同步器 *AbstractQueuedSynchronizer* 是用来构建锁的基础框架，使用一个 int 变量表示同步状态。 它提供了一些基础方法，可以供锁的实现者调用来实现自己的锁的逻辑。  
它提供的方法主要分为三类：
* 独占式的获取和释放同步状态
* 共享式的获取和释放同步状态
* 查询同步队列中的等待线程

总体来说，同步器是一个桥梁，连接线程访问以及同步状态控制等底层技术和不同锁(比如 Lock, CountDownLatch)的接口定义.

## 重入锁
重入锁就是支持重入的锁，它表示已经获取了锁的线程，还可以继续获取锁而不会被阻塞。*synchronized* 就是一个隐式的重入锁。  
重入锁在多次获取锁时，需要进行计数自增。在释放锁的时候，需要计数自减。当计数为 0, 表示锁被释放，其它线程可以尝试获取该锁了。  
重入锁有公平和非公平之分，公平的重入锁是在指先等待锁的线程先尝试争夺锁，非公平的重入锁是指线程在可以尝试获取锁的时候，立即尝试，而不管同步队列里是否已经有了其它等待更久的线程。 
因为一般情况下，释放锁的线程接下来继续尝试获取锁的概率很大，所以导致公平锁会有更多的线程切换，降低了效率，而非公平锁则保证了吞吐量，却有可能导致其它线程等待太久而饥饿。  

## 读写锁
前面讲到的锁都是排它锁，同一时刻只能有一个线程持有锁，任何其它线程想获取锁，则必须阻塞等待。  
读写锁允许同一时间有多个读线程访问，当写线程访问时，阻塞其它所有读线程和写线程, 且写线程的操作对其它读线程和写线程可见。这样通过读锁和写锁分离，使得在一般场景下(读操作多于写操作), 并发性比一般的排他锁有了很大提升。  
