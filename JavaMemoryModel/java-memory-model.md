Introduction to java memory model
在 Java 中，所有实例域，静态域和数组元素都存在堆内存中，堆内存在线程之间共享。Java 不同线程之间的通信是通过共享内存模型来隐式进行的， 又因为现在处理器大量使用各种 cache 以及其它的硬件和编译器优化, 不同线程之间的通信很可能会遇到各种奇怪的内存可见性问题。 Java 线程之间的通信由 Java 内存模型 JMM 控制， JMM 决定一个线程对共享变量的写入何时对另一个线程可见。

# 重排序
在执行程序时，为了提高性能，编译器和处理器常常会对指令做重排序。 重排序分为三种类型
1. 编译器优化排序。 编译器在不改变单线程 as-if-serial 语义前提下，可以重新安排语句的执行顺序
2. 指令级并行的重排序。 如果不存在数据依赖性，处理器可以使用指令级并行技术来将多条指令并行执行，也就改变了语句对应机器指令的执行顺序
3. 内存系统的重排序。 由于处理器使用了读/写 cache(为了批处理指令，还可以合并对同一地址的操作，尽量减少对总线的占用), 使得加载和存储操作看上去可能是乱序的

JMM 可以通过编译器重排序规则禁止特定类型的编译器重排序， 对于处理器重排序， JMM 可以通过在编译时插入内存屏障来禁止特定类型的处理器重排序。 它确保在不同编译器和不同的处理器平台之上，通过禁止特定的重排序，为程序员提供一致的内存可见性保证。

## 数据依赖性
如果单线程中两个操作访问同一个变量，且其中一个操作为写操作，则两个操作之间存在数据依赖性。对于存在数据依赖性的操作，如果改变执行顺序，则程序的执行结果就会被改变。因此编译器和处理器都不会对存在数据依赖性的操作重排序。
## as-if-serial 语义
不管怎么重排序，单线程程序的执行结果不能被改变。这就保证了程序员编写单线程程序时，无需担心内存可见性问题。
## 重排序对多线程的影响
```java
class Test {
  int a = 0;
  boolean flag = false;
  
  public void write() {
    a = 1;         //1
    flag = true;   //2
  }
  
  public void read() {
    if (flag) {    //3
      int i = a * a;  //4
    }
  }
}
```
假设由两个线程A和B，A先执行 write() 方法， B接着执行 read() 方法。则B在执行操作4的时候，能否看到A线程对变量a 的写入呢？答案是不一定能看到。因为操作1和2 没有数据依赖，编译器和处理器都可以对1和2 进行重排序。 操作3和4 也一样。如果执行顺序是2->3->4>1,则B线程看不到A线程对变量 a 的写入。如果B线程对操作3，4重排序，处理器可以通过猜测提前计算 a * a的结果，将计算结果存在寄存器中，然后判断条件是否为真，如果为真，则将结果写入变量i中。在这种顺序下，程序结果被改变。在单线程中，对存在控制依赖性的操作重排序不会改变执行结果。

# 顺序一致性
顺序内存性模型是一个理论参考模型，在设计内存模型时，作为参照。
## 顺序一致性内存模型
1. 一个线程中的所有操作必须按照程序顺序来执行
2. 不管程序是否同步，所有线程都只能看到一个单一的操作执行顺序。在顺序一致性模型中，所有操作都必须原子执行且立即对其它线程可见。
在概念上，顺序一致性内存模型有一个全局内存，同一时间，只有一个线程可以访问该内存，并且线程必须按照程序顺序执行操作。所有线程看到的整体执行顺序是一致的
## 数据竞争与顺序一致性
当程序没有正确同步时，就可能存在数据竞争。数据竞争的定义：**在一个线程中写入一个变量，在另一个线程中读同一个变量，且读和写操作没有通过同步来排序**。这里的同步是广义上的同步，包括对同步原语(synchronized, volatile, final)的正确使用。
如果程序正确同步，程序的运行结果与该程序在顺序一致性模型中的执行结果相同。

# 内存模型综述
在设计内存模型时，主要考虑两个因素
1. 程序员对内存模型的使用。程序员希望基于一个强内存模型来编程，易于理解，易于编程
2. 编译器和处理器对内存模型的实现。编译器和处理器希望实现一个弱内存模型，内存模型对它们的束缚越少越好，因为这样就能做尽可能多的优化来提升性能

这两个因素互相矛盾，因此JSR-133 专家组的目标则是找好一个平衡点，为程序员保证一个足够强的内存可见性，另一方面，对编译器和处理器的限制尽可能的少。因此，专家组提出了 happen-before 的概念。
## happen-before 的定义
JSR-133 使用 happen-before 的概念来指定两个操作之间的执行顺序，这两个操作可以在同一线程，或者不同线程之间。
1. 如果一个操作 happen-before 另一个操作，那么第一个操作的执行结果将对第二个操作可见，而且第一个操作的执行顺序排在第二个操作之前
2. 虽然两个操作具有happen-before 关系，但是并不意味着 Java 平台的具体实现必须按照 happen-before 指定的顺序执行。两个操作可以重排序，只要重排序后的执行结果和按照指定顺序执行的结果相同，则允许这种重排序

上面的1 是JMM对程序员的承诺。如果操作A happen-before B, 则 A的结果对B可见，且A先于B执行。虽然实际上可能并不是这样，但是程序员不用care，因为即使不一样，编译器和处理器做出的改动，对程序员编程来说没有影响，因为执行结果不会改变。
上面的2 是JMM对编译器和处理器重排序的约束原则。 只要不改变程序的执行结果，编译器和处理器怎么优化都行。因为程序员并不关心两个操作是否真的被重排序，只关心程序的运行结果不能被改变。
## happen-before 的规则
1. 程序顺序规则：一个线程中的每个操作，happen-before 与该线程中任意的后续操作
2. 监视器锁规则： 对一个锁的解锁， happen-before 于随后对这个锁的加锁
3. volatile 变量规则： 对一个volatile 的写， happen-before 于任意后续对这个变量的读
4. 传递性： 如果A happen-before B, B happen-before C, 则 A happen-before C.
5. start 规则： 如果线程A 执行 ThreadB.start(), 那么 A 线程的 ThreadB.start() 操作 happen-before 于线程B 中的任意操作
6. join 规则： 如果线程A 执行 ThreadB.join() 并成功返回，那么线程B中的任意操作 happen-before 于线程A从 ThreadB.join() 操作成功返回

