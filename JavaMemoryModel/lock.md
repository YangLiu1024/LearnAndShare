# Lock
Java 里每一个对象都可以作为锁。当访问同步方法，或者同步代码块时，都需要先获取锁，在退出或抛异常时，必须释放锁。  
JVM 实现同步是通过两个指令来完成的，*monitorenter* 和 *monitorexit*. *monitorenter* 被插入到同步代码块开始的位置，*monitorexit* 被插入到方法结束处和异常处， JVM 要保证每一个 *monitorenter* 都必须有对应的 *monitorexit* 与之配对。 
Java 每个对象都有一个 *monitor* 与之关联，当 *monitor* 被持有时，它将处于锁定状态。线程执行到 *monitorenter* 指令时，会尝试获取对象对应 *monitor* 的所有权，即尝试获取对象的锁。  

## Java 对象头
Java 对象在内存中存储的分布可以分为三部分：对象头, 实例数据，以及用于对齐的填充 padding。  
对于普通对象，对象头分为两部分，Mark Word 以及 Class Word. Mark Word 存储对象的 hashcode 以及锁信息，Class Word 存储该对象的 class 对象的地址。 对于数组对象，还有一个 Word 用来存储数据的长度。
### Mark Word
Mark Word 默认存储对象的 hashcode, 分代年龄和锁标记位。在运行期间，Mark Word 里存储的数据会随着锁标志位的变化而变化。  
锁的状态可以从无锁 -> 偏向锁 -> 轻量级锁 -> 重量级锁，以及标志为 GC. 锁的状态可以升级，但是不能降级，这是为了提高获得和释放锁的效率。
![](image/mark-word.png)

### 重量级锁
重量级锁就是传统的锁，依赖于系统底层 mutex lock 来实现的。而线程之间的切换总是需要从用户态切换到核心态，这个成本非常高，导致效率低下。  
JDK1.6 为了减少这种重量级锁的使用，引入了轻量级锁和偏向锁。  
#### monitor
每一个 java 对象都有一个 monitor 与之对应，该 monitor 可以在对象创建时，或者对象作为锁时创建。该 monitor  对象用来存储想要获取对应锁对象的线程的信息。    
monitor 有三个主要部分，*entry set*, *owner*, *wait set*. 
当线程执行到指令 *monitorenter*, 则会进入该 monitor 对象的 *entry set*, 尝试获取 owner 的所有权。  
owner 同一时间只能被一个线程持有，如果某个线程持有成功，则进入 owner 区域，并将 monitor 计数器加 1. 如果该线程之后又尝试获取同样的锁，因为它已经获取了，则直接将计数器再加 1.   
如果持有锁的线程在运行期间，调用 wait, 则会释放对 owner 的占有，进入 *wait set*, 等待被其它线程唤醒。  
持有锁的线程同步块代码运行结束，即在执行 *monitorexit* 时，会将计数器减 1, 如果计数为 0, 则表示该线程需要释放 monitor. 释放 monitor 的时候会通知 entry set, 让它们继续争夺锁。
 
### 轻量级锁
轻量级锁并没有取代重量级锁，它的本意是在没有同一时间下多线程竞争的前提下，减少传统重量级锁使用产生的消耗。  
即轻量级锁适用的场景是线程交替执行同步块的情况，如果存在同一时间访问同一锁的情况，则轻量级锁会膨胀为重量级锁。  

#### 轻量级锁的获取
1. 在代码进入同步块的时候，如果同步对象锁状态为无锁状态(偏向锁标志为0，锁标志位为 01), JVM 首先在当前线程的栈帧中建立一个名为锁记录(Lock Record)的空间, 该空间分为两部分。第一部分名为 displaced mark word, 用于存储锁对象当前的 mark word 的拷贝. 第二部分名为 owner
2. 在拷贝成功后， JVM 使用 CAS(旧值为拷贝过来的 mark word 里的 hashcode, 新值为 lock record 地址) 操作尝试将锁对象 mark word 更新为指向 lock record 的指针，并将 lock record 第二部分的 owner 指针指向锁对象 mark word. 如果更新成功，执行 #3, 如果失败，执行 #4
3. 若成功，表示该对象还没有被其它线程占据， 即锁对象的对象头仍然是 hascode 信息，那么该线程就拥有了该对象的锁，并且锁对象 mark word 的锁标志位设置为 *00*, 表示锁当前处于轻量级状态。
4. 若失败，即锁对象头里已经被修改为了其它值， 则JVM 会首先检查锁对象的 mark word 是否指向当前线程栈帧的锁记录，如果是就说明当前线程已经拥有了这个对象的锁，那么就可以直接进入同步代码块继续执行，如果不是，那么说明多个线程同时竞争该锁对象，那么轻量级锁就要膨胀为重量级锁，锁标志的状态改为 *10*, mark word 中存储的就是指向重量级锁(互斥量) 的指针，后面等待锁的线程也要进入阻塞状态。而当前线程便尝试使用自旋来获取锁，自旋就是为了不让线程阻塞，而采用循环去获取锁的过程。

#### 轻量级锁的释放
1. 如果一个线程已经获取了轻量级锁，表示其栈帧里存储的是锁对象的 hashcode mark word, 那么通过 CAS 操作尝试将锁对象的 mark word 替换为该 hashcode. 此时，旧值是该栈帧的锁记录地址，新值是线程栈帧拷贝的 mark word 信息。
2. 如果替换成功，表示没有其它线程竞争该锁，同步过程完成，锁对象变成无锁状态
3. 如果替换失败，说明有其它线程尝试过获取该锁，此时锁已经膨胀，那么就要在释放锁的同时，唤醒被挂起的线程

### 偏向锁
研究发现，大部分情况下，锁不仅不存在多线程竞争，而且总是被同一线程多次获得，为了让线程获得锁的代价更低引入了偏向锁。  
偏向锁并不会主动释放，这样在每次偏向锁进入的时候都会判断该锁是否偏向当前线程，如果是，则不需要进行额外操作，直接进入同步代码块。  
所以偏向锁适用于有同步代码块，但是不存在多线程竞争的场景。
#### 偏向锁对象头
当 JVM 启用了偏向锁，新建对象时，其对象头 Mark word 里就会存 [threadId, epoch, age, 1, 01], threadid 初始为空。  
当没有启用偏向锁，新建对象时，其对象头 Mark word 里就会存 [hashcode, age, 0, 01]

#### 偏向锁的获取
1. 访问 Mark word中锁标志位是否为 01, 如果是，则表示锁对象未锁定，如果偏向锁标志位为 1, 则为可偏向状态, 执行 #2, 如果不是，则尝试获取轻量级锁。
2. 如果为可偏向状态，则测试线程 ID 是否为当前线程，如果是，则执行 #5，如果不是，执行 #3
3. 如果线程 ID 并没有指向当前线程，则通过 CAS 竞争锁。旧值为空，新值为当前线程 ID。 如果竞争成功，则将 Mark word 中线程 ID 改为当前线程， 然后执行 #5, 如果失败，执行 #4
4. 如果 CAS 竞争锁失败，则表示存在竞争。当到达全局安全点，挂起获得该锁的线程，如果该线程不处于活动状态，则撤销偏向锁，将对象头设置为无锁状态，且不再可偏向。否则将偏向锁升级为轻量级锁，然后该线程继续执行下去。
5. 执行同步代码

#### 偏向锁，轻量级锁，重量级锁之间的转换
![](./image/lock-transition.png)

#### 批量重偏向
当只有一个线程反复进入同步块时，偏向锁带来的性能开销基本可以忽略，但是当有其它线程竞争时，就需要等到全局安全点时撤销偏向锁或升级为轻量级锁，这个过程也会消耗一定的性能。  
所以说如果存在多线程竞争，那么偏向锁的存在不仅不能提高性能，而且会导致性能下降，因此 JVM 中增加了一种批量重偏向/撤销的机制。  
1. 首先引入一个概念 epoch, 其本质是一个时间戳，代表了偏向锁的有效性。epoch 存在了可偏向对象的 mark word 中，对象所属的 class 信息中，也会存储一个 epoch 值。
2. 每当遇到一个全局安全点，比如要对 class C 进行批量重偏向，则首先对 class C 中保存的 epoch 进行增加操作，得到一个新的 epoch-new
3. 然后扫描所有持有 class C 实例的线程栈，根据线程栈的信息判断出该线程是否锁定了该对象，然后将 epoch-new 的值付给被锁定对象，也就是现在偏向锁还在被使用的对象才会被赋值 epoch-new
4. 退出安全点后，当有线程需要尝试获取偏向锁时，直接检查 class C 中存储的 epoch 值是否与目标对象中存储的 epoch 值相等，如果不相等，则说明该对象的偏向锁已经无效了。此时竞争线程可以尝试对此对象重新进行偏向操作。

## Conclusion
![](./image/lock.png)
重量级锁依赖于 monitor, 而 monitor 又依赖于系统互斥量，进行线程之间的切换，消耗大。适用于有多线程竞争，且竞争时间长的场景。  
轻量级锁在获取和释放的时候都至少需要一次 CAS 操作，消耗比重量级锁小。适用于无多线程竞争，或多线程交替所用锁的场景，也允许短时间的锁竞争，因为轻量级锁会进行自旋。但自旋也会一直消耗CPU, 如果一直等不到锁，则会膨胀为重量级锁。  
偏向锁适用于无多线程竞争的场景，只有第一次初始化偏向线程时有 CAS 操作，其它时候只需要进行比较操作即可。当存在多线程竞争时，则膨胀为轻量级锁。  

当线程访问同步代码块，首先检查锁对象的状态。  
如果已经是重量级锁(锁标志位为 10), 那么找到对应的 monitor 对象，查看当前 owner 是否为当前线程。如果是，则计数器加 1, 线程继续执行。如果不是，则线程挂起，进入 *entry set* 等待调度。monitor 的 owner 同一时间只能被一个线程占有，所以当 entry set 里某一个线程占有 owner 时，该线程则获取了锁。当该线程运行同步代码块结束，或者抛出异常，运行 monitorexit 指令，计数器减 1. 如果计数器为 0, 表示当前线程已经不再占有 monitor, 将 owner 重置为 null, 这样其它线程就可以继续争夺锁对象。如果线程在执行过程中调用了 wait 方法，则该线程也会释放对 monitor 的占有，进入 *wait set*, 等待其它线程唤醒。  

如果是无锁状态，检查偏向锁标志位是否为 1. 若是可偏向状态，则检查 thread id 是否为当前线程 Id, 如果是，则直接执行同步代码，如果不是，则通过 CAS 操作尝试更新 mark word thread id, 此时，旧值为空，新值为当前线程 id. 所以，只会在第一个线程首次进入代码块时，才可能偏向成功。否则，表示存在第二个线程尝试竞争锁，CAS 操作将失败，那么等到全局安全点，检查持有偏向锁的线程状态。如果处于未活动状态，则将偏向锁偏向于当前线程或者撤销偏向锁(撤销和重偏向更复杂一些，可以参考其它文档)。如果持有偏向锁的线程处于活动状态， 将其挂起，然后将偏向锁升级为轻量级锁。  
此时会在原持有偏向锁的线程和当前线程中分配锁记录，并将锁对象无锁状态的 mark word 拷贝到原持有偏向锁的线程和当前线程的锁记录，原持有偏向锁的线程将锁对象 mark word 改为 [stack pointer, 00]. 唤醒持有偏向锁的线程，让其在安全点继续执行。当前线程也会继续进行自旋，尝试将锁对象 mark word 锁记录指针指向当前线程锁记录。如果自旋期间，原持有偏向锁(现在已经是轻量级锁)的线程释放了锁，则当前线程获得锁。如果没有，则当前线程会将锁对象 mark word 修改为 [monitor pointer, 10], 并阻塞自己。原持有偏向锁(现在已经是轻量级锁)的线程在尝试释放锁时，首先会检查现在锁对象 mark word 里锁记录指针是否仍然指向自己的锁记录，并且锁标志位是否和自己锁记录里拷贝的 mark word 锁标志位一样，如果一样，表示没有其它线程在执行同步代码期间竞争，则直接释放锁，无需其它操作。如果不一样，表示锁已经升级，除了释放锁，还需要唤醒挂起的线程。那么唤醒的线程开始新一轮的竞争。