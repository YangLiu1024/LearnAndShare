# Number Precision
```js
const a = 0.1;
const b = 0.2;
console(a + b)//0.30000000000000004
console.log(a)//0.1, 这里的 0.1 表示 a 的值真的是精确的 0.1 吗？
```
在我们使用数值时，我们使用的是十进制，计算机存储的是二进制。所以计算机首先就要转换十进制为二进制。至于怎么转换，整数部分，一直除以 2，直到商为0, 反向取每次的余数，小数部分，一直乘以 2，顺序取每次的整数部分，然后继续以小数部分乘以 2，直到结果为0.  
我们以 169.45 为例，整数部分为 169，小数部分为 0.45.  
对于整数部分，  
169 / 2 = 84 余 1  
84 / 2 = 42 余 0  
42 / 2 = 21 余 0  
21 / 2 = 10 余 1  
10 / 2 = 5 余 0  
5 / 2 = 2 余 1  
2 / 2 = 1 余 0  
1 / 2 = 0 余 1  
所以整数部分转换为二进制为 <pre>10101001</pre>
小数部分为 0.45，  
0.45 * 2 = 0.9 -> 0  
0.9 * 2 = 1.8 -> 1  
0.8 * 2 = 1.6 -> 1  
0.6 * 2 = 1.2 -> 1  
0.2 * 2 = 0.4 -> 0  
0.4 * 2 = 0.8 -> 0  
0.8 * 2 = 1.6 -> 1   
 
可以看出小数的表示进入了循环, 所以，0.45 的小数表示为 <pre>01<u>1100</u></pre>
所以 169.45 就可以表示为 <pre>10101001.01<u>1100</u></pre>
这个是 169.45 的原码。  
## 浮点数的表示
### 普通标准
在计算机原理里，浮点数的表示形式为 *M \* R ^ E*, M 是尾数，R 是基数(一般为 2)，E 是阶码，也就是指数. 32 bit 机器里，阶码为 8 bit, 其中包含一位阶码的符号位，尾数为 24 bit, 其中包含 一位的符号位，且约定尾数在规格化后，其十进制值需要大于等于 0.5, 这就意味着尾数的表示形式为 *0.1xxxxx*。    
举例来说，二进制数 *10111.1011*, 其浮点数表示为 *0.101111011 \* 2 ^ 101*. 在存储的时候，因为尾数第一位一定是1，就不需要存下来，从第二位开始保存，这样可以节省空间并且提升精度。  
### IEEE 754 标准
浮点数的表示也还有其它标准，比如 *IEEE 754*.  
* 32 bit 机器，阶码 8 bit, 尾数 24 bit
* 64 bit 机器，阶码 11 bit, 尾数 53 bit
* 基数为 2
* 阶码采用移码表示，偏置值在8 位阶码时，为 2 ^ 7 - 1, 在 11位阶码时，为 2 ^ 10 - 1, 符号位为1时，表示正数，为0 时表示负数(这个定义与原码，反码，补码定义不一样)， 尾数采用原码，包含一位符号位
* <b>规格化原码尾数最高位恒为 1， 且不在尾数中表示出来</b>, 这个和上述浮点数表示有区别
* 尾数有 52 位，加上隐藏位，53 bit 能表示的十进制精度在 16-17 之间
* 如果一个数的二进制表示，转化为十进制时，该数有至少 17 位有效数字，那么该数字的精度取舍应该保证，再转换该十进制数为二进制时，和之前的二进制表示一样
* 如果一个十进制数的有效位数 <= 15, 那么转换该数为二进制，然后再转换为十进制，其结果应该和最开始的十进制相同


举例来说，十进制值 100.25 表示为 二进制为 *1100100.01*, 表示为浮点数为 *1.10010001 * 2 ^ 110*, 那么阶码就是*1111111 + 110 = 10000101*, 尾数部分就是*10010001<s>000...</s>*, 尾数后续的 0 是为填充满 23 bit.

## 浮点数的加减运算
设有两浮点数，X = Mx * 2 ^ Ex, Y = My * 2 ^ Ey, 且已经规格化，以 IEEE 754 标准为例，即尾数的最高位为 1， 且并没有表示在 尾数里。为了实现浮点数的加减，有以下步骤：  
### 1. 对阶
将阶码小的尾数右移，每右移一次，其阶码加1，直至阶码相同。  
### 2. 尾数的加减
对阶完成后，对尾数进行加减
### 3. 规格化操作
如果结果的两个符号位不同，表示加减法运算尾数结果溢出，此时需要将结果右移一位，阶码加 1. 这种操作称为右规。右规时，左侧补符号位。     
如果结果的符号位相同，但结果的最高位和符号位相同，需要将结果连续左移，直到最高位数值位与符号位的值不同为止，此时 阶码减去移动的次数。这种操作称为左规。左规时，右侧补0，尾数最高位移位作为符号位。  
### 4. 舍入
执行对阶或右规时，尾数低位上的数值会被移掉，使数值的精度受到影响。常用0舍1入法。  
当末尾移掉的最高位为 1 时，在尾数的末位 加 1. 如果加 1后又使尾数溢出，则要再进行一次右规。  
### 5. 检查阶码是否溢出
若阶码下溢，则运算结果置为机器0， 若上溢，则置溢出标志。

```bash
1. 已知两个浮点数， x = 2^+010 * (0.11011011), y = 2^100 * (-0.10101100), 求 x + y?

x 阶码为 00 010， 尾数为 00.1101 1011
y 阶码为 00 100， 尾数为负数，所以表示为补数，为 11.0101 0100
因为 y 阶码较大， x 需要对阶为 00 100, 00.001101 1011.
需要注意的是，在对阶时，符号位参与位移，且符号位保持不变。
对阶后，尾数相加，需要注意的是，符号位也参与计算
00.0011011011
11.01010100
-------------
11.1000101011
计算完成后，发现符号位为 11，高位为1，结果需要左规，左规一次后则满足，此时阶码需要 减 1
所以结果为 00011， 11.000101011
然后开始 0舍1入，发现丢弃位为 1， 所以尾数末位 + 1 -> 11.00010110
可以发现，因为有丢弃，所以结果的精度是丢失了的。
最后需要将补码再转换为原码，然后进行存储。
```
```bash
2. 已知两个浮点数， x = 2^-101 * (-0.101000), y = 2^-100 *(0.111011), 求 x - y?
x 阶码为负数，表示为补码 11011，尾数为负数，表示为补码 11.011000
y 阶码为负数，表示为补码 11100, 因为是 -y, 也表示为补码 11.000101
x 需要对阶为 11100， 11.1011000，然后尾数相加
11.1011000
11.000101
----------
10.1100010
符号位不同，需要右规一次，且阶码 + 1。需要注意的是，右规的时候，左侧需要补位符号位。上述结果右规后为
11101， 11.01100010
因为舍弃最高位为1，所以尾数末位需要 + 1 -> 11.011001
```
```bash
3. 某数采用 IEEE 754 单精度浮点格式表示为 C640 0000H, 则该数是多少？
首先将该值展开 1100 0110 0100 0000 0000....
根据 IEEE 754标准，第一位 为符号位，然后 8 位为阶码 10001100
又因为阶码表示为移码， 10001100 = 1111111 + x <=> 1000000 + 1100 = 10000000 - 1 + x => x = 13
尾数为 100000000xxx, 因为是 IEEE 754 规范，尾数实际上是 1.1000xxxx, 所以转换为十进制后，该数为 -1.5 * 2 ^ 13
```
```bash
4. 在 IEEE 754 float 标准型，-8.25 会存储为？
IEEE float 标准，阶码 8 bit, 尾数 24 bit.
-8.25 转为二进制为 - 1000.01 -> -1.00001 * 2 ^ 3
所以阶码为 3， 011 + 1111111 = 10000010
最后结果为 110 0000 1000 0010 0000000xxxx -> C104 0000H
```
JS 里使用 Number 来保存数字，它遵循 IEEE 754 标准，使用 64 位双精度浮点数来存储所有 Number 类型值。  

那么对于 169.45， 在 JS 里该怎么表示呢？<pre>10101001.01<u>1100</u> = 1.010100101<u>1100</u> * 2 ^ 7</pre>
那么符号位就是 *0*, 指数值是 7， 那么指数位就是 *1023 + 7* = *01000000110*， 尾数部分为 *010100101<u>1100</u>*, 注意IEEE 规范，高位一定是1，且不表示在尾数里，所以尾数部分只会保存小数点后的 bits.  
<b>又因为尾数部分是 52 位，对于 169.45 这种无法精确保存的值，必然存在精度丢失</b>。那么这个时候，169.45 这个值在计算机里存储的，其实已经不是精确的 169.45 了。
<pre>0 01000000110 010100101 <u>1100</u>xxx 110</pre>  
然后在前端显示时，又需要转换为 十进制，那么它的值就是 *169 + 0.25 + 0.2 - 0.2\*2 ^ (-11 * 4)*, 这里的 0.25 是 *2 ^ -2*, 后面的部分是根据等比数列求和(因为尾数部分按照 1100 循环)，又因为尾数总共 52 位，除掉前面的 *010100101*， 循环部分就有(43/4 = 10 余3)，又因为余3能够存储 *11*, 所以总共等比项有 11项。*0.2 \*2^-44*换算为10进制值表示为 <pre>1.136868377216160297393798828125e-14</pre>
所以 169.45 的二进制转换为十进制后，<pre>169.449999999999988631316227838397...</pre>
又因为 IEEE 规范，因为 169.45 字面量，只有 5 位有效数字，所以将其转换为二进制，并且再转换为十进制时，其精度不应该改变。
```js
169.45 // 169.45
169.45.toPrecision(16)//'169.4500000000000'
169.45.toPrecision(17)//'169.44999999999999'
169.45.toPrecision(18)//'169.449999999999989'
169.45.toPrecision(19)//'169.4499999999999886'
169.45.toPrecision(20)//'169.44999999999998863'
169.45.toPrecision(21)//'169.449999999999988631'
```
那么再回到最开始的问题，(0.1 + 0.2) = 0.3000000000000004.  
对于 0.1 <pre>二进制： 1.1<u>0011</u>* 2 ^ -4
阶码为 1023 - 4 = 01111110001
尾码为 1<u>0011</u>...001(1), 因为尾码只有 52 bit, 所以最后舍弃了 1, 那么尾数末位应该 + 1
所以尾数最后是 1 <u>0011</u>...010
最后的结果就是 0 01111110001 1<u>0011</u>...010</pre>
对于0.2 
<pre>二进制： 1.1<u>0011</u>* 2 ^ -3
阶码是 1023 - 3 = 01111110010
尾码和 0.1 一样，所以最后结果就是 0 01111110010 1<u>0011</u>...010
</pre>
对于 *0.1 + 0.2*， 因为阶码不同，首先需要对阶。一般是低阶往高阶对齐，因为这样，舍弃的是低位数据， 这样造成的误差肯定比舍弃高位数据小。  
<pre>将 0.1 对阶，对阶前
0 01111110001  1(这里的1是最高位隐藏的 1).1<u>0011</u>...010
对阶后
0 01111110010  0.11<u>0011</u>...01(0)
然后 加 0.2
 0.11<u>0011</u>...01(0)
 1.1<u>0011</u>...010
---------------------*
10.01<u>1001</u>...11(0)

尾数相加的结果产生了进位，所以阶码应该 + 1, 然后尾数右移
所以阶码变成了01111110011， 尾数变成了 1.<u>0011</u>...(10)
可见舍弃部分的最高位为 1， 所以尾数末位需要 + 1，那么尾数就变成 1.<u>0011</u>...0100
最后 0.1 + 0.2 的结果就表示为 0 01111110011 <u>0011</u>....0100
将其转换为 十进制，1.<u>0011</u>....0100 * 2 ^ -2
0.01<u>0011</u>....0100
0.25 + (2^-5 + 2^ -6)(1- 2^(-4n))/(1-2 ^ -4) + 2 ^ -52
其中 n = 12, 因为 0011 在尾数里重复了 12 次
上式 = 0.25 + 0.05 + 0.2 * 2 ^ -52
    = 0.3 + 4.4408920985 * 10 ^ -17
    = 0.3<u>0</u>...44408920985, 重复的 0 有 15 位
</pre>
又因为 IEEE 规范，当一个二进制数表示为十进制数时，如果其有效位数超过了 17 位，那么转化后的十进制数再重新转换为二进制时，需要和最开始的二进制数相同。
<pre>
对于 0.1 + 0.2 的二进制数转化为十进制时，其有效数字超过了 17 位，如果这个时候我们将精度设置在 16位，出来的结果是 0.3， 但是 0.3 转化为二进制后，其尾数结果为 1.<u>0011</u>..., 和 0.1 + 0.2 的结果 1.<u>0011</u>...0100 不同，所以不可以采用 16 精度。
那么就需要采用 17 位精度，即 0.30000000000000004，将该数转化为二进制，则和 0.1 + 0.2 的二进制表达相同。
以上， 0.1 + 0.2 === 0.30000000000000004
</pre>
我们可以再尝试一下 *1.3 - 0.6*
<pre>
1.3 表示为 1.0<u>1001</u>..., 规格化后，因为舍弃的是 1，所以末位 + 1， 为 1.0<u>1001</u>...101， 阶码为 0
-0.6 表示为 -0.<u>1001</u>, 规格化后，-1.<u>0011</u> * 2 ^ -1, 阶码为 -1， 尾数为 <u>0011</u>..., 最后表示为 1 (-1) u>0011</u>... 
在计算 1.3 -0.6 时，将 -0.6 尾数表示为转码
11(符号位).<u>1100</u>...1101
然后进行对阶， 尾数需要右移一位
11.1<u>1100</u>...110(1)
00.0<u>1001</u>...101
--------------------------*

</pre>