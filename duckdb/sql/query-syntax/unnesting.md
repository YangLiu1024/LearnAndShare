# Unnesting
duckdb 支持嵌套的数组类型，或者 Map 类型。一般来说，常用的还是数组。  
数组的生成，大多数是通过聚合函数，比如 list, max_by 等会返回 list 的函数，常见的比如 top-N
```js
duckdb> from tt2;
┌───┬────┐
│ i ┆ j  │
╞═══╪════╡
│ 0 ┆ 15 │
│ 1 ┆  6 │
│ 2 ┆  7 │
│ 3 ┆  8 │
│ 4 ┆  9 │
│ 5 ┆ 10 │
│ 6 ┆ 11 │
│ 7 ┆ 12 │
│ 8 ┆ 13 │
│ 9 ┆ 14 │
└───┴────┘
// 找到每一列的三个最大值，不一定在同一行， 返回值是 list
duckdb> select max(COLUMNS(*), 3) from tt2;
┌───────────┬──────────────┐
│ i         ┆ j            │
╞═══════════╪══════════════╡
│ [9, 8, 7] ┆ [15, 14, 13] │
└───────────┴──────────────┘
```
在使用这些值的时候，通常需要将数组展开，这就需要使用 *unnest*，value 会被展开为行
```js
// unnest 用来将 数组，struct 等展开，默认展开一级。只能用在 select 后
duckdb> SELECT unnest([1, 2, 3]) as i;
┌───┐
│ i │
╞═══╡
│ 1 │
│ 2 │
│ 3 │
└───┘
// 展开结构体
duckdb> SELECT unnest({'a': 42, 'b': 84});
┌────┬────┐
│ a  ┆ b  │
╞════╪════╡
│ 42 ┆ 84 │
└────┴────┘
// 只展开一级，数组也是类似的
duckdb> SELECT unnest({'a': 42, 'b': {'c': 2}});
┌────┬────────┐
│ a  ┆ b      │
╞════╪════════╡
│ 42 ┆ {c: 2} │
└────┴────────┘
// 如果指定 recursive, 则会一直展开
duckdb> SELECT unnest([{'a': 42, 'b': 84}, {'a': 100, 'b': NULL}], recursive := true);
┌─────┬────┐
│ a   ┆ b  │
╞═════╪════╡
│  42 ┆ 84 │
│ 100 ┆    │
└─────┴────┘

// 也可以指定展开级数
duckdb> SELECT unnest([[[1, 2], [3, 4]], [[5, 6], [7, 8, 9], []], [[10, 11]]], max_depth := 2) as i;
┌───────────┐
│ i         │
╞═══════════╡
│ [1, 2]    │
│ [3, 4]    │
│ [5, 6]    │
│ [7, 8, 9] │
│ []        │
│ [10, 11]  │
└───────────┘
// 展开多列时，如果列的值是 scalar，则会被复用
duckdb> SELECT unnest([1, 2, 3]) as i, 10 as j;
┌───┬────┐
│ i ┆ j  │
╞═══╪════╡
│ 1 ┆ 10 │
│ 2 ┆ 10 │
│ 3 ┆ 10 │
└───┴────┘

// 如果两列的个数不同，则会填充 NULL
duckdb> SELECT unnest([1, 2, 3]) as i, unnest([10, 11]) as j;
┌───┬────┐
│ i ┆ j  │
╞═══╪════╡
│ 1 ┆ 10 │
│ 2 ┆ 11 │
│ 3 ┆    │
└───┴────┘
// 如果一列的值都是 list, 则会次第展开
duckdb> SELECT unnest(l) + 10 as i FROM (VALUES ([1, 2, 3]), ([4, 5])) tbl(l);
┌────┐
│ i  │
╞════╡
│ 11 │
│ 12 │
│ 13 │
│ 14 │
│ 15 │
└────┘
```
